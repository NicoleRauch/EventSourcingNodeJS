%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{}

\begin{center}
{
\LARGE
Why Event Sourcing?
}

\vspace{2em}

or:

\vspace{2em}

{
\Large
How this all began
}
\end{center}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{}

\renewcommand{\SPACE}{1em}

\textbf{SoCraTes Conference 2015:}
\vspace{\SPACE}                 
                
11 users were incorrectly denied registration due to a bug
\vspace{\SPACE}                 
                  
We could not find out from the system who these users were
\vspace{\SPACE}                 
                  
2 or 3 complained, but the others? Gone (and probably disappointed).


\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{}

\renewcommand{\SPACE}{1em}

\textbf{The bug:}
\vspace{\SPACE}                 

2-phase registration (reservation $\rightarrow$ registration)
\vspace{\SPACE}                 
                  
reservation was made, but registration was denied
\vspace{\SPACE}                 
                  
reservation token only contained session id

was deleted after 30 minutes
\vspace{\SPACE}                 
                  
$\Longrightarrow$ we were unable to see who actually made the reservation
\vspace{\SPACE}                 
             
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{}

\begin{center}
\LARGE
How can this be improved?
\end{center}             
                  
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{}

\begin{center}
{
\LARGE
Event Sourcing
}

\vspace{2em}

or:

\vspace{2em}

{
\Large
Don't Drop Data!
}
\end{center}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{The Classical Approach: Relational Database}

\begin{itemize}                
\item Only captures current state!
\item No information about previous states
\item No information why some change happened
\end{itemize}
                   
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{How to improve this?}

\renewcommand{\SPACE}{1em}

\begin{enumerate}
\item Record everything that happened, and why.
\item Derive your current application state from that log.
\end{enumerate}         
                  
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Event Sourcing}

\begin{minipage}{.7\textwidth}
\begin{onlyenv}<1>
\includegraphics[width=\textwidth]{../EventSourcing1.pdf}
\end{onlyenv}
\begin{onlyenv}<2>
\includegraphics[width=\textwidth]{../EventSourcing2.pdf}
\end{onlyenv}
\begin{onlyenv}<3-4>
\includegraphics[width=\textwidth]{../EventSourcing3.pdf}
\end{onlyenv}
\begin{onlyenv}<5>
\includegraphics[width=\textwidth]{../EventSourcing4.pdf}
\end{onlyenv}
\end{minipage} \hfill
\begin{minipage}{0.25\textwidth}
\small
\begin{onlyenv}<1-3>
Set ticket quota
\onslide+<2-3>
\begin{itemize}
\item Ticket quota set
\end{itemize}
\end{onlyenv}
\begin{onlyenv}<4-5>
Book ticket
\begin{itemize}
\item Ticket booked
\item Sold out
\item You already booked a ticket
\end{itemize}
\end{onlyenv}
\end{minipage}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{The Ticket Quota}

\begin{onlyenv}<1-3>
The event constants:

\begin{highlight}{1}
module.exports = {
  TICKET_QUOTA_WAS_SET: 'TICKET-QUOTA-WAS-SET',
  // ...
}
\end{highlight}

\onslide+<2->
The event constructor:

\begin{highlight}{2}
ticketQuotaWasSet: function (quota) {
    return {event: e.TICKET_QUOTA_WAS_SET, quota};
}
\end{highlight}

\onslide+<3->
\begin{highlight}{3}
CommandProcessor.prototype.setQuota = function (newQuota) {
  return roomQuotaWasSet(newQuota);
};
\end{highlight}
\end{onlyenv}

\begin{onlyenv}<4->
\begin{highlight}{4}
function ReadModel(events) {
  this._quota = undefined;
  this.process(events);
}
\end{highlight}
\onslide+<5->
\begin{highlight}{5}
var processQuota = function (quota, event) { 
  return event.event === e.ROOM_QUOTA_WAS_SET ? event.quota : quota;
};
\end{highlight}
\onslide+<6->
\begin{highlight}{6}
ReadModel.prototype.process = function (events) {
  this._quota = R.reduce(processQuota, this._quota, events);
};
\end{highlight}
\onslide+<7->
\begin{highlight}{7}
ReadModel.prototype.quota = function () {
  return this._quota;
};
\end{highlight}
\end{onlyenv}

\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Standard Event Sourcing Scenario}

\begin{itemize}
\item Event sourcing in application server
\item Incremental updates of event store, write models and read models
\item Write models must be updated synchronously
\item Read models can be updated asynchronously
\end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Event Sourcing in Node.js}

Let's understand how node.js works

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Node.js}

\begin{onlyenv}<1>
\includegraphics[width=.7\textwidth]{../Nodejs1.pdf}
\end{onlyenv}

\begin{onlyenv}<2>
\includegraphics[width=.7\textwidth]{../Nodejs2.pdf}
\end{onlyenv}

\begin{onlyenv}<3>
\includegraphics[width=.7\textwidth]{../Nodejs3.pdf}
\end{onlyenv}

\begin{onlyenv}<4>
\includegraphics[width=.7\textwidth]{../Nodejs4.pdf}
\end{onlyenv}

\hfill 

\begin{tiny}
\makebox[\textwidth][r]{\url{http://blog.mixu.net/2011/02/01/understanding-the-node-js-event-loop/}}
\end{tiny}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Mongo DB}

\begin{itemize}
\item No transactions
\item No optimistic locking
\onslide+<2->
\item We implemented optimistic locking ourselves
\end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Mongo DB}

\begin{center}

\begin{onlyenv}<1>
\includegraphics[width=.85\textwidth]{../OptimisticLocking1.pdf}
\end{onlyenv}

\begin{onlyenv}<2>
\includegraphics[width=.85\textwidth]{../OptimisticLocking2.pdf}
\end{onlyenv}

\begin{onlyenv}<3>
\includegraphics[width=.85\textwidth]{../OptimisticLocking3.pdf}
\end{onlyenv}

\begin{onlyenv}<4>
\includegraphics[width=.85\textwidth]{../OptimisticLocking4.pdf}
\end{onlyenv}

\begin{onlyenv}<5>
\begin{tikzpicture}%
% put: x (from left) , y (from bottom)
\put(-240,-130){\includegraphics[height=\textheight]{../fireballs.jpg}}%
\end{tikzpicture}%
\end{onlyenv}


\begin{onlyenv}<6>
\includegraphics[width=.85\textwidth]{../OptimisticLocking5.pdf}
\end{onlyenv}

\begin{onlyenv}<7>
\includegraphics[width=.85\textwidth]{../OptimisticLocking6.pdf}
\end{onlyenv}

\end{center}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Our Pre-Event-Sourcing Architecture}

\includegraphics[width=.7\textwidth]{../Nodejs3.pdf}

\begin{itemize}
\item Request comes in, reads \& writes data from/to DB, returns
\item Nothing$^*$ is kept in memory between requests
\end{itemize}

{ \tiny $^*$ Apart from the caching that is done by \texttt{require} }
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Event Sourcing Without Global State?}

\includegraphics[width=.5\textwidth]{../EventSourcing4.pdf}

\begin{itemize}
\item What about the read and write models?
\end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Working Hypothesis}

\textbf{Rough Estimations:} \\[.7em]
We expected a couple hundred events altogether

\onslide+<2->
\vspace{5em}

\textbf{Working Hypothesis:} \\[.7em]
We can hydrate the models from the eventstore on each request

\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{On Opening the Registration}

\onslide+<2->

Registration began...

\onslide+<3->

\vspace{3em}

~ \hspace{10em} ... but nobody registered!
 
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{What was going on?}

\renewcommand{\SPACE}{.6em}

Remember: 2-phase registration (reservation $\rightarrow$ registration)
\vspace{\SPACE}

\onslide+<2->
First user came in:
\vspace{\SPACE}

\includegraphics[width=.5\textwidth]{../Nodejs3.pdf}

\onslide+<3->
Reading from DB parallelized it, so more users came in and read from DB

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{What was going on?}

\renewcommand{\SPACE}{3em}

\begin{center}

\begin{onlyenv}<1>
First user was able to persist her reservation:

\includegraphics[width=.4\textwidth]{../OptimisticLocking5.pdf}
\end{onlyenv}

\begin{onlyenv}<2>
All subsequent users produced conflicts: 

\includegraphics[width=.4\textwidth]{../OptimisticLocking6.pdf}
\end{onlyenv}

\begin{onlyenv}<3>
\Large
And retried.
\end{onlyenv}

\begin{onlyenv}<4>
\LARGE
And got conflicts again.
\end{onlyenv}

\begin{onlyenv}<5>
\Huge
And retried again.
\end{onlyenv}

\begin{onlyenv}<6>
Slow hydrating on read
\vspace{\SPACE}

$\Longrightarrow$ Huge number of parallel requests
\vspace{\SPACE}

$\Longrightarrow$ Self-propelling disaster.
\end{onlyenv}

\end{center}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{The End}

After 25 minutes, I shut down the server.
                  
\onslide+<2->
                  
\vspace{3em}

~ \hspace{10em} Nobody had been able to register.
                  
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Problem I}

Hydrating the read and write models takes longer than we had expected.
                  
\onslide+<2->
                  
\vspace{3em}

$\Longrightarrow$ We must cache the read and write models.
                  
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Caching the Global EventStore}

\renewcommand{\SPACE}{-0.9em}

\onslide+<1->
\begin{highlight}{1}
function getGlobalEventStoreForWriting(url, callback) {
\end{highlight}
%%
\onslide+<2->
\vspace{\SPACE}
\begin{highlight}{2}
  const cacheKey = keyFor(url, GLOBAL_EVENT_STORE_FOR_WRITING);
  const cachedStore = cache.get(cacheKey);
  if (cachedStore) {
    return callback(null, cachedStore);
  }
\end{highlight}
%%
\onslide+<3->
\vspace{\SPACE}
\begin{highlight}{3}
  mongo_async.getEventStore(url, function (err, eventStore) {
    if (err || !eventStore) { return callback(err); }
\end{highlight}
%%
\onslide+<4->
\vspace{\SPACE}
\begin{highlight}{4}
    const cachedWhileFetching = cache.get(cacheKey);
    if (cachedWhileFetching) {
      return callback(null, cachedWhileFetching);
    }
\end{highlight}
%%
\onslide+<5->
\vspace{\SPACE}
\begin{highlight}{5}
    cache.set(cacheKey, eventStore);
    callback(null, eventStore);
\end{highlight}
%%
\onslide+<3->
\vspace{\SPACE}
\begin{highlight}{3}
  });
\end{highlight}
%%
\onslide+<1->
\vspace{\SPACE}
\begin{highlight}{1}
}
\end{highlight}


\end{frame}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{``True'' Event Sourcing and Our Adaptation}

\begin{center}

\begin{onlyenv}<1>
\includegraphics[width=.7\textwidth]{../EventSourcing4.pdf}
\end{onlyenv}

\begin{onlyenv}<2>
\includegraphics[width=.7\textwidth]{../EventSourcingOurStyle.pdf}
\end{onlyenv}


\begin{onlyenv}<3>

\textbf{Important:}

\vspace{4em}
Persisting the event store must be the \textbf{last} action to avoid parallelization!
\end{onlyenv}

\end{center}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Caching the Read Models}

\renewcommand{\SPACE}{-0.9em}

\onslide+<1->
\begin{highlight}{1}
function getReadModel(url, key, ReadModel, callback) {
\end{highlight}
%%
\onslide+<2->
\vspace{\SPACE}
\begin{highlight}{2}
  const cacheKey = keyFor(url, key);
  var cachedModel = cache.get(cacheKey);
  if (cachedModel) {
    return callback(null, cachedModel);
  }
\end{highlight}
%%
\onslide+<3->
\vspace{\SPACE}
\begin{highlight}{3}
  mongo_async.getEventStore(url, function (err, eventStore) {
    if (err || !eventStore) { return callback(err); }
\end{highlight}
%%
\onslide+<4->
\vspace{\SPACE}
\begin{highlight}{4}
    var cachedWhileFetching = cache.get(cacheKey);
    if (cachedWhileFetching) {
      return callback(null, cachedWhileFetching);
    }
\end{highlight}
%%
\onslide+<5->
\vspace{\SPACE}
\begin{highlight}{5}
    const newModel = new ReadModel(eventStore);
    cache.set(cacheKey, newModel);
    callback(null, newModel);
\end{highlight}
%%
\onslide+<3->
\vspace{\SPACE}
\begin{highlight}{3}
  });
\end{highlight}
%%
\onslide+<1->
\vspace{\SPACE}
\begin{highlight}{1}
}
\end{highlight}

\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Problem II}

Parallelization leads to write conflicts

\onslide+<2->
                  
\vspace{3em}

$\Longrightarrow$ We must eliminate parallelization.

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Eliminating Parallelization}

\begin{center}

\begin{onlyenv}<1>
\includegraphics[width=.45\textwidth]{../EliminateWriteConflicts1.pdf}
\end{onlyenv}

\begin{onlyenv}<2>
\includegraphics[width=.45\textwidth]{../EliminateWriteConflicts2.pdf}
\end{onlyenv}

\begin{onlyenv}<3>
\includegraphics[width=.45\textwidth]{../EliminateWriteConflicts3.pdf}
\end{onlyenv}

\end{center}

\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Benefits}

Synchronous code between loading and updating the event store

\onslide+<2->
\vspace{2em}

$\Longrightarrow$ No possibility for write conflicts

\onslide+<3->
\vspace{2em}

$\Longrightarrow$ We can even save unconditionally

\onslide+<4->
\vspace{2em}

$\Longrightarrow$ Event store is rather a backup

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Tradeoffs}

We cannot run multiple node.js processes in parallel

\onslide+<2->
\vspace{2em}

$\Longrightarrow$ No way of scaling

\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}{Thank you very much!}

        Slides: \url{https://github.com/NicoleRauch/EventSourcingNodeJS} 
        \vspace{1em}

        Code: \url{https://github.com/softwerkskammer/Agora}
        
        ~\\[1em]
        \begin{block}{Nicole Rauch}
        \begin{description}[Twitterxx]
                \item[E-Mail]  \href{mailto:info@nicole-rauch.de}{\texttt{info@nicole-rauch.de}}
                \item[Twitter] \href{http://twitter.com/NicoleRauch}{\texttt{@NicoleRauch}}
                \item[Web] \href{http://www.nicole-rauch.de}{\texttt{http://www.nicole-rauch.de}}
        \end{description}
        \end{block}
\end{frame}

