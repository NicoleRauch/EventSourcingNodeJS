%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{}

\begin{center}
{
\LARGE
Why Event Sourcing?
}

\vspace{2em}

or:

\vspace{2em}

{
\Large
How this all began
}
\end{center}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{}

  SoCraTes Conference 2015
                  
                  11 users were incorrectly denied registration due to a bug
                  
                  We could not find out from the system who these users were
                  
                  2 or 3 complained, but the others? Gone (and probably disappointed).


\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{}

The bug: 2-phase registration (reservation -> registration)
                  
                  reservation was made, but registration was denied
                  
                  reservation token only contained session id
                  was deleted after 30 minutes
                  
                  -> we were unable to see who actually made the reservation
                  
                  How can this be improved?
                  
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{}

\begin{center}
{
\LARGE
Event Sourcing
}

\vspace{2em}

or:

\vspace{2em}

{
\Large
Don't Drop Data!
}
\end{center}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{}

Usually: Relational Database
                  
                  Only captures current state!
                  
                  No information about previous states
                  No information why some change happened
                  
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{}

How to improve this?
                  
                  Record everything that happened, and why.
                  
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Event Sourcing}

\begin{onlyenv}<1>
\includegraphics[width=.7\textwidth]{../EventSourcing1.pdf}
\end{onlyenv}

\begin{onlyenv}<2>
\includegraphics[width=.7\textwidth]{../EventSourcing2.pdf}
\end{onlyenv}

\begin{onlyenv}<3-4>
\begin{minipage}{.7\textwidth}
\includegraphics[width=\textwidth]{../EventSourcing3.pdf}
\end{minipage} \hfill
\end{onlyenv}
\begin{onlyenv}<3>
\begin{minipage}{0.25\textwidth}
\small
Set ticket count
\begin{itemize}
\item Ticket count set
\end{itemize}
\end{minipage}
\end{onlyenv}
\begin{onlyenv}<4>
\begin{minipage}{0.25\textwidth}
\small
Book ticket
\begin{itemize}
\item Ticket booked
\item Sold out
\item You already booked a ticket
\end{itemize}
\end{minipage}
\end{onlyenv}

\begin{onlyenv}<5>
\includegraphics[width=.7\textwidth]{../EventSourcing4.pdf}
\end{onlyenv}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Standard Event Sourcing Scenario}

\begin{itemize}
\item Event sourcing in application server
\item Incremental updates of event store, write models and read models
\item Write models must be updated synchronously
\item Read models can be updated asynchronously
\end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Event Sourcing in Node.js}

Let's understand how node.js works

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Node.js}

\begin{onlyenv}<1>
\includegraphics[width=.7\textwidth]{../Nodejs1.pdf}
\end{onlyenv}

\begin{onlyenv}<2>
\includegraphics[width=.7\textwidth]{../Nodejs2.pdf}
\end{onlyenv}

\begin{onlyenv}<3>
\includegraphics[width=.7\textwidth]{../Nodejs3.pdf}
\end{onlyenv}

\begin{onlyenv}<4>
\includegraphics[width=.7\textwidth]{../Nodejs4.pdf}
\end{onlyenv}

\hfill 

\begin{tiny}
\makebox[\textwidth][r]{\url{http://blog.mixu.net/2011/02/01/understanding-the-node-js-event-loop/}}
\end{tiny}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Mongo DB}

\begin{itemize}
\item No transactions
\item No optimistic locking
\onslide+<2->
\item We implemented optimistic locking ourselves
\end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Mongo DB}

\begin{center}

\begin{onlyenv}<1>
\includegraphics[width=.85\textwidth]{../OptimisticLocking1.pdf}
\end{onlyenv}

\begin{onlyenv}<2>
\includegraphics[width=.85\textwidth]{../OptimisticLocking2.pdf}
\end{onlyenv}

\begin{onlyenv}<3>
\includegraphics[width=.85\textwidth]{../OptimisticLocking3.pdf}
\end{onlyenv}

\begin{onlyenv}<4>
\includegraphics[width=.85\textwidth]{../OptimisticLocking4.pdf}
\end{onlyenv}

\begin{onlyenv}<5>
\includegraphics[width=.85\textwidth]{../OptimisticLocking5.pdf}
\end{onlyenv}

\begin{onlyenv}<6>
\includegraphics[width=.85\textwidth]{../OptimisticLocking6.pdf}
\end{onlyenv}

\end{center}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Our Initial Architecture}

\includegraphics[width=.7\textwidth]{../Nodejs3.pdf}

\onslide+<2->

\begin{itemize}
\item Request comes in, reads \& writes data from/to DB, returns
\item Nothing$^*$ is kept in memory between requests
\end{itemize}

{ \tiny $^*$ Apart from the caching that is done by \texttt{require} }
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Event Sourcing Without Global State?}

\includegraphics[width=.5\textwidth]{../EventSourcing4.pdf}

\onslide+<2->

\begin{itemize}
\item What about the read and write models?
\end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Working Hypothesis}

\textbf{Rough Estimations:} \\[.7em]
We expected a couple hundred events altogether

\onslide+<2->
\vspace{5em}

\textbf{Working Hypothesis:} \\[.7em]
We can hydrate the models from the event store on each request

\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{On Opening the Registration}

\onslide+<2->

Registration began...

\onslide+<3->

\vspace{3em}

~ \hspace{10em} ... but nobody registered!
 
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{What was going on?}

Remember: 2-phase registration (reservation -> registration)

First user came in:

\includegraphics[width=.4\textwidth]{../Nodejs3.pdf}

Reading from DB parallelized it, so more users came in and read from DB

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{What was going on?}

First user was able to persist her reservation:

\includegraphics[width=.4\textwidth]{../OptimisticLocking5.pdf}

All subsequent users produced conflicts: 

\includegraphics[width=.4\textwidth]{../OptimisticLocking6.pdf}

And retried.

And got conflicts again.

And retried again.

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{}

Because in fact it was

\includegraphics[width=.4\textwidth]{../OptimisticLocking6.pdf}

so we had a self-propelling disaster.

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{The End}

After 25 minutes, I shut down the server.
                  
\onslide+<2->
                  
\vspace{3em}

~ \hspace{10em} Nobody had been able to register.
                  
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Problem I}

Hydrating the read and write models takes longer than we had expected.
                  
\onslide+<2->
                  
\vspace{3em}

$\Longrightarrow$ We must cache the read and write models.
                  
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Caching Read and Write Models: Step 1}

\renewcommand{\SPACE}{-0.9em}

\onslide+<1->
\begin{highlight}{1}[basicstyle=\footnotesize\ttfamily\alt<1>{}{\color{\greyedout}}]{JavaScript}
function getGlobalEventStoreForWriting(cacheKey, callback) {
\end{lstlisting}
%%
\onslide+<2->
\vspace{\SPACE}
\begin{lstlisting}{JavaScript}
  const cachedStore = cache.get(cacheKey);
  if (cachedStore) {
    return callback(null, cachedStore);
  }
\end{lstlisting}
%%
\onslide+<3->
\vspace{\SPACE}
\begin{lstlisting}{JavaScript}
  eventstore.getEventStore(url, function (err, eventStore) {
    if (err || !eventStore) { return callback(err); }
\end{lstlisting}
%%
\onslide+<4->
\vspace{\SPACE}
\begin{lstlisting}{JavaScript}
    const cachedStore2 = cache.get(cacheKey);
    if (cachedStore2) {
      return callback(null, cachedStore2);
    }
\end{lstlisting}
%%
\onslide+<5->
\vspace{\SPACE}
\begin{lstlisting}{JavaScript}
    cache.set(cacheKey, eventStore);
    callback(null, eventStore);
\end{lstlisting}
%%
\onslide+<3->
\vspace{\SPACE}
\begin{lstlisting}{JavaScript}
  });
\end{lstlisting}
%%
\onslide+<1->
\vspace{\SPACE}
\begin{lstlisting}{JavaScript}
}
\end{lstlisting}


\end{frame}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{}




 and incrementally update them with each event.


For this, we did not exactly follow the Event Sourcing paradigm

(event store in memory, save unconditionally after each write (?))

\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\begin{frame}[fragile]{}

%\end{frame}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Analysis II}

Because of parallelization due to database accesses, and because of large windows of parallelization due to the slow request processing, it was almost impossible for users to get through.

\onslide+<2->
                  
\vspace{3em}

$\Longrightarrow$ We must control parallelization.
                  
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{What did we improve?}

Problem: We had concurrent writes for the event store which conflicted after the first write

Solution: Get rid of concurrent writes

Problem. Hydrating the read and write models is slow.


Saving must be the very last thing we do - because that's the point where we get exposed to parallelization

Make sure that there is no database access between the fetching and the saving of the event store - first load everything from database, then get the store from the cache
This way the code that updates the event store is always synchronous


\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\begin{frame}[fragile]{}

%\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Tradeoffs}

We cannot run multiple node.js processes in parallel any more.

\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}{Thank you very much!}

        Code \& slides: \url{https://github.com/NicoleRauch/...}
        
        ~\\[1em]
        \begin{block}{Nicole Rauch}
        \begin{description}[Twitterxx]
                \item[E-Mail]  \href{mailto:info@nicole-rauch.de}{\texttt{info@nicole-rauch.de}}
                \item[Twitter] \href{http://twitter.com/NicoleRauch}{\texttt{@NicoleRauch}}
                \item[Web] \href{http://www.nicole-rauch.de}{\texttt{http://www.nicole-rauch.de}}
        \end{description}
        \end{block}
\end{frame}

